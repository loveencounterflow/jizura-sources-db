#!/usr/bin/env bash
set -euo pipefail

#-----------------------------------------------------------------------------------------------------------
enodir() {
  # path="$1"
  # echo "no such directory: $path"
  exit 1; }

#-----------------------------------------------------------------------------------------------------------
enocmd() {
  name="$1"
  echo "executable not found: $name"
  exit 1; }

#-----------------------------------------------------------------------------------------------------------
realpath() {
  # thx to https://github.com/whatwg/html-build/issues/90
  OURPWD=$PWD
  cd "$(dirname "$1")" || enodir
  LINK=$(readlink "$(basename "$1")")
  while [ "$LINK" ]; do
    cd "$(dirname "$LINK")" || enodir
    LINK=$(readlink "$(basename "$1")")
  done
  REALPATH="$PWD/$(basename "$1")"
  cd "$OURPWD" || enodir
  echo "$REALPATH"
}
# realpath "$@"

# #-----------------------------------------------------------------------------------------------------------
# cwd=$(pwd)
# home="$(realpath "$(realpath "${BASH_SOURCE[0]}" | xargs dirname)"/..)"; cd "$home" || enodir


#-----------------------------------------------------------------------------------------------------------
# thx to https://chatgpt.com/s/t_6942f8bb1740819187963acd9603fc3d
pipe_or_fail() {
  local tmp rc
  tmp=$(mktemp) || return 1
  #.........................................................................................................
  local -a prod=()
  local -a cons=()
  local mode=prod
  #.........................................................................................................
  for arg in "$@"; do
    if [[ $arg == -- && $mode == prod ]]; then
      mode=cons
      continue
    fi
    if [[ $mode == prod ]]; then
      prod+=("$arg")
    else
      cons+=("$arg")
    fi
  done
  #.........................................................................................................
  # sanity check
  if ((${#prod[@]} == 0 || ${#cons[@]} == 0)); then
    echo "pipe_or_fail: missing producer or consumer" >&2
    rm -f "$tmp"
    return 2
  fi
  #.........................................................................................................
  # run producer
  if "${prod[@]}" >"$tmp"; then
    # read first line of $tmp file;
    #   if it starts with the pattern given, use pager;
    #   otherwise, just print it out.
    #.......................................................................................................
    cmd_use_pspg_re='^Ω\s*command:\s*use-pspg\s*Ω$'
    #.......................................................................................................
    IFS= read -r first_line <"$tmp"
    #.......................................................................................................
    if [[ $first_line =~ $cmd_use_pspg_re ]]; then
      tail -n +2 "$tmp" | "${cons[@]}"
    else
      cat "$tmp"
      fi
    # "${cons[@]}" <"$tmp"
    rc=$?
  else
    rc=$?
  fi
  #.........................................................................................................
  rm -f "$tmp"
  return "$rc"
}

#-----------------------------------------------------------------------------------------------------------
has_pager_switch() {
  for arg in "$@"; do
    case "$arg" in
      -p|--pager)
        return 0
        ;;
    esac
  done
  return 1; }

# #...........................................................................................................
# # echoes to stdout, not reliable
# # see https://chatgpt.com/s/t_6947bb3c4e788191bbf6acecd22f8660
# stream_to_pager_or_fail() {
#   local pager_pid
#   local line

#   # Start pager, reading from stdin
#   # "${cons[@]}" &
#   "${pager_cmd[@]}" &
#   pager_pid=$!

#   # Ensure pager is cleaned up on exit or error
#   trap 'kill "$pager_pid" 2>/dev/null; wait "$pager_pid" 2>/dev/null' EXIT

#   # Stream input line by line
#   while IFS= read -r line; do
#     # Detect error condition (example: special marker)
#     if [[ $line == ERROR:* ]]; then
#       echo "error detected: $line" >&2
#       kill "$pager_pid" 2>/dev/null
#       wait "$pager_pid" 2>/dev/null
#       trap - EXIT
#       return 1
#     fi

#     printf '%s\n' "$line"
#   done

#   # Normal EOF
#   wait "$pager_pid"
#   trap - EXIT
#   return 0; }
